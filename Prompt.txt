CartSlic.js:

import { createSlice, createAsyncThunk } from '@reduxjs/toolkit';
import { getCart, addToCart, removeFromCart } from '../api/cartApi';

// Async thunk for fetching cart
export const fetchCart = createAsyncThunk(
  'cart/fetchCart',
  async () => {
    const data = await getCart();
    return data;
  }
);

// Async thunk for adding item to cart
export const addToCartThunk = createAsyncThunk(
  'cart/addItem',
  async ({ productId, quantity }) => {
    await addToCart(productId, quantity);
    // After adding item, fetch the updated cart
    const cartData = await getCart();
    return cartData;
  }
);

// Async thunk for updating quantity
export const updateCartItem = createAsyncThunk(
  'cart/updateItem',
  async ({ itemId, newQty }) => {
    await addToCart(itemId, newQty);
    return { itemId, newQty };
  }
);

// Async thunk for removing item
export const removeCartItem = createAsyncThunk(
  'cart/removeItem',
  async ({ itemId }) => {
    await removeFromCart(itemId);
    return itemId;
  }
);

const initialState = {
  items: [],
  loading: false,
  error: null,
  operationLoading: false,
  totalQuantity: 0,
  totalPrice: 0,
};

const cartSlice = createSlice({
  name: 'cart',
  initialState,
  reducers: {},
  extraReducers: (builder) => {
    // Add to cart
    builder
      .addCase(addToCartThunk.pending, (state) => {
        state.operationLoading = true;
        state.error = null;
      })
      .addCase(addToCartThunk.fulfilled, (state, action) => {
        state.operationLoading = false;
        if (action.payload && Array.isArray(action.payload.items)) {
          state.items = action.payload.items;
          state.totalQuantity = action.payload.items.reduce((acc, item) => acc + (item.quantity || 0), 0);
          state.totalPrice = action.payload.items.reduce((acc, item) => 
            acc + ((item.product?.price || 0) * (item.quantity || 0)), 0);
        } else {
          // After adding item, fetch the updated cart
          return {
            ...state,
            items: [],
            totalQuantity: 0,
            totalPrice: 0
          };
        }
      })
      .addCase(addToCartThunk.rejected, (state, action) => {
        state.operationLoading = false;
        state.error = action.error.message;
      });

    // Fetch cart
    builder
      .addCase(fetchCart.pending, (state) => {
        state.loading = true;
        state.error = null;
      })
      .addCase(fetchCart.fulfilled, (state, action) => {
        state.loading = false;
        if (action.payload && Array.isArray(action.payload.items)) {
          state.items = action.payload.items;
          state.totalQuantity = action.payload.items.reduce((acc, item) => acc + (item.quantity || 0), 0);
          state.totalPrice = action.payload.items.reduce((acc, item) => 
            acc + ((item.product?.price || 0) * (item.quantity || 0)), 0);
        } else {
          state.items = [];
          state.totalQuantity = 0;
          state.totalPrice = 0;
        }
      })
      .addCase(fetchCart.rejected, (state, action) => {
        state.loading = false;
        state.error = action.error.error;
      })

    // Update cart item
    builder
      .addCase(updateCartItem.pending, (state) => {
        state.operationLoading = true;
        state.error = null;
      })
      .addCase(updateCartItem.fulfilled, (state, action) => {
        state.operationLoading = false;
        const { itemId, newQty } = action.payload;
        const item = state.items.find(item => item.product.id === itemId);
        if (item) {
          const oldQuantity = item.quantity;
          item.quantity = item.quantity + newQty;
          state.totalQuantity = state.totalQuantity - oldQuantity + item.quantity;
          state.totalPrice = state.items.reduce((acc, item) => acc + (item.product.price * item.quantity), 0);
        }
      })
      .addCase(updateCartItem.rejected, (state, action) => {
        state.operationLoading = false;
        state.error = action.error.message;
      })

    // Remove cart item
    builder
      .addCase(removeCartItem.pending, (state) => {
        state.operationLoading = true;
        state.error = null;
      })
      .addCase(removeCartItem.fulfilled, (state, action) => {
        state.operationLoading = false;
        const itemId = action.payload;
        const item = state.items.find(item => item.product.id === itemId);
        if (item) {
          state.totalQuantity -= item.quantity;
          state.totalPrice -= item.product.price * item.quantity;
          state.items = state.items.filter(item => item.product.id !== itemId);
        }
      })
      .addCase(removeCartItem.rejected, (state, action) => {
        state.operationLoading = false;
        state.error = action.error.message;
      })
  },
});

export const { clearCart } = cartSlice.actions;
// Selectors
export const selectCartItems = state => state.cart.items;
export const selectCartLoading = state => state.cart.loading;
export const selectCartOperationLoading = state => state.cart.operationLoading;
export const selectCartError = state => state.cart.error;
export const selectCartTotal = state => {
  return state.cart.items.reduce((total, item) => total + (item.product.price * item.quantity), 0);
};

export default cartSlice.reducer;

cartApi.js:import axiosInstance from "./axiosInstance";

export const getCart = async () => {
  const res = await axiosInstance.get("/cart/");
  return res.data;
};

export const addToCart = async (productId, quantity = 1) => {
  const res = await axiosInstance.post(`/cart/${productId}/`, { quantity });
  return res.data;
};

export const removeFromCart = async (productId) => {
  const res = await axiosInstance.delete(`/cart/${productId}/`);
  return res.data;
};
,CartPage.jsx: import React, { useEffect } from "react";
import { useDispatch, useSelector } from "react-redux";
import { Link } from "react-router-dom";
import { fetchCart, updateCartItem, removeCartItem } from "../slices/cartSlice";

export default function CartPage() {
  const dispatch = useDispatch();
  const items = useSelector(state => state.cart.items);
  const loading = useSelector(state => state.cart.loading);
  const operationLoading = useSelector(state => state.cart.operationLoading);
  const error = useSelector(state => state.cart.error);
  const totalPrice = useSelector(state => state.cart.totalPrice);

  console.log("error: ",error)
  // Fetch cart data
  useEffect(() => {
    dispatch(fetchCart());
  }, [dispatch]);

  // Update quantity
  const updateQuantity = async (itemId, newQty) => {
    if (operationLoading) return; // Prevent multiple operations while loading
    try {
      await dispatch(updateCartItem({ itemId, newQty })).unwrap();
    } catch (err) {
      alert(err.message || "Failed to update quantity");
    }
  };

  // Remove item
  const removeItem = async (itemId) => {
    if (operationLoading) return; // Prevent multiple operations while loading
    try {
      await dispatch(removeCartItem({ itemId })).unwrap();
    } catch (err) {
      alert(err.message || "Failed to remove item");
    }
  };

  if (loading) return <p className="text-center py-10 text-gray-500">Loading cart...</p>;
  if (error) return <p className="text-center py-10 text-red-500">{error}</p>;
  if (!items || items.length === 0)
    return (
      <div className="text-center">
        <p className="text-gray-500 mb-4">Your cart is empty.</p>
        <Link
          to="/"
          className="bg-black dark:bg-white dark:text-black text-white px-6 py-3 rounded-full hover:scale-105 transition"
        >
          Continue Shopping
        </Link>
      </div>
    );

  return (
    <div className="min-h-screen bg-gray-50 dark:bg-black text-black dark:text-white px-6 py-10">
      <h2 className="text-3xl font-bold text-center mb-8">ðŸ›’ Your Cart</h2>

      <div className="max-w-4xl mx-auto bg-white dark:bg-gray-900 shadow-lg rounded-2xl p-6">
        {items.map((item) => (
          <div
            key={item.id}
            className="flex flex-col sm:flex-row justify-between items-center border-b border-gray-300 dark:border-gray-700 py-4"
          >
            <div className="flex items-center gap-4 w-full sm:w-auto">
              <img
                src={
                  `https://res.cloudinary.com/dq7zkxtnj/${item.product.image}`
                }
                alt={item.product.name}
                className="w-20 h-20 object-cover rounded-lg"
              />
              <div>
                <h3 className="font-semibold text-lg">{item.product.name}</h3>
                <p className="text-gray-600 dark:text-gray-400">
                  â‚¹{item.product.price}
                </p>
              </div>
            </div>

            <div className="flex items-center gap-3 mt-3 sm:mt-0">
              <button
                onClick={() => {
                  if (item.quantity > 1) {
                    updateQuantity(item.product.id, -1);
                  } else {
                    removeItem(item.product.id);
                  }
                }}
                disabled={operationLoading}
                className={`bg-gray-200 dark:bg-gray-800 px-3 py-1 rounded ${
                  operationLoading ? 'opacity-50 cursor-not-allowed' : 'cursor-pointer'
                }`}
              >
                âˆ’
              </button>
              <span>{item.quantity}</span>
              <button
                onClick={() => updateQuantity(item.product.id, 1)}
                disabled={operationLoading}
                className={`bg-gray-200 dark:bg-gray-800 px-3 py-1 rounded ${
                  operationLoading ? 'opacity-50 cursor-not-allowed' : 'cursor-pointer'
                }`}
              >
                +
              </button>
            </div>

            <div className="flex flex-col items-center mt-3 sm:mt-0">
              <p className="font-semibold">
                â‚¹{(item.product.price * item.quantity).toLocaleString("en-IN", { 
                    minimumFractionDigits: 2, 
                    maximumFractionDigits: 2 
                })}
            </p>

              <button
                onClick={() => removeItem(item.product.id)}
                disabled={operationLoading}
                className={`text-red-500 text-sm mt-2 hover:underline ${
                  operationLoading ? 'opacity-50 cursor-not-allowed' : 'cursor-pointer'
                }`}
              >
                {operationLoading ? 'Removing...' : 'Remove'}
              </button>
            </div>
          </div>
        ))}

        <div className="flex justify-between items-center mt-6 border-t pt-4">
          <h3 className="text-xl font-bold">Total:</h3>
            <p className="text-2xl font-semibold">
            â‚¹{totalPrice.toLocaleString("en-IN", { minimumFractionDigits: 2, maximumFractionDigits: 2 })}
            </p>
        </div>

        <div className="text-center mt-8">
          <button className="bg-black dark:bg-white dark:text-black text-white px-8 py-3 rounded-full font-semibold hover:scale-105 transition">
            Proceed to Checkout
          </button>
        </div>
      </div>
    </div>
  );
}
, Cart Model.py: from django.db import models
from django.contrib.auth.models import User
from product.models import Product
import uuid

class Cart(models.Model):
    id = models.UUIDField(primary_key=True, default=uuid.uuid4, editable=False)
    user = models.ForeignKey(User, on_delete=models.CASCADE, related_name='carts')
    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)

    def total_price(self):
        return sum(item.subtotal() for item in self.items.all())

    def total_items(self):
        return sum(item.quantity for item in self.items.all())

    def __str__(self):
        return f"Cart({self.user.username})"


class CartItem(models.Model):
    id = models.UUIDField(primary_key=True, default=uuid.uuid4, editable=False)
    cart = models.ForeignKey(Cart, on_delete=models.CASCADE, related_name='items')
    product = models.ForeignKey(Product, on_delete=models.CASCADE)
    quantity = models.PositiveIntegerField(default=1)
    added_at = models.DateTimeField(auto_now_add=True)

    def subtotal(self):
        return self.product.price * self.quantity

    def __str__(self):
        return f"{self.product.name} Ã— {self.quantity}"
serializers.py: from rest_framework import serializers
from .models import Cart, CartItem
from product.models import Product


class ProductSerializer(serializers.ModelSerializer):
    """Minimal product serializer for displaying product info in cart"""
    class Meta:
        model = Product
        fields = ['id', 'name', 'price', 'image']


class CartItemSerializer(serializers.ModelSerializer):
    """Serializer for items inside a cart"""
    product = ProductSerializer(read_only=True)
    product_id = serializers.PrimaryKeyRelatedField(
        queryset=Product.objects.all(),
        source='product',
        write_only=True
    )
    subtotal = serializers.SerializerMethodField()

    class Meta:
        model = CartItem
        fields = ['id', 'product', 'product_id', 'quantity', 'subtotal']

    def get_subtotal(self, obj):
        return obj.subtotal()


class CartSerializer(serializers.ModelSerializer):
    """Main Cart serializer"""
    items = CartItemSerializer(many=True, read_only=True)
    total_price = serializers.SerializerMethodField()
    total_items = serializers.SerializerMethodField()

    class Meta:
        model = Cart
        fields = ['id', 'user', 'items', 'total_items', 'total_price', 'created_at', 'updated_at']
        read_only_fields = ['user', 'total_price', 'total_items']

    def get_total_price(self, obj):
        return obj.total_price()

    def get_total_items(self, obj):
        return obj.total_items()

    def create(self, validated_data):
        """Automatically link cart to current user"""
        user = self.context['request'].user
        cart = Cart.objects.create(user=user)
        return cart

views.py: from rest_framework.views import APIView
from rest_framework.permissions import IsAuthenticated
from rest_framework.response import Response
from rest_framework import status
from django.shortcuts import get_object_or_404
from .models import Cart, CartItem
from product.models import Product
from .serializers import CartSerializer, CartItemSerializer


class CartView(APIView):
    permission_classes = [IsAuthenticated]

    # ðŸ›’ GET: Retrieve user's cart
    def get(self, request):
        try:
            cart, created = Cart.objects.get_or_create(user=request.user)
            if created or not cart.items.exists():
                # Return empty cart instead of 404
                return Response({"items": []}, status=status.HTTP_200_OK)

            serializer = CartSerializer(cart)
            return Response(serializer.data, status=status.HTTP_200_OK)

        except Exception as e:
            print("Exception in CartView:", e)
            return Response({"error": str(e)}, status=status.HTTP_400_BAD_REQUEST)

    # âž• POST: Add product to cart
    def post(self, request, product_id):
        try:
            quantity = int(request.data.get("quantity", 1))
            if quantity < 1:
                quantity = 1

            product = get_object_or_404(Product, id=product_id)
            cart, _ = Cart.objects.get_or_create(user=request.user)

            cart_item, created = CartItem.objects.get_or_create(
                cart=cart, product=product, defaults={"quantity": quantity}
            )
            if not created:
                cart_item.quantity += quantity
                cart_item.save()

            return Response({
                "message": f"{product.name} added to cart",
                "quantity": cart_item.quantity
            }, status=status.HTTP_200_OK)

        except Exception as e:
            print(f"Error adding to cart: {e}")
            return Response({"error": str(e)}, status=status.HTTP_400_BAD_REQUEST)

    # âŒ DELETE: Remove product from cart
    def delete(self, request, product_id):
        try:
            cart = get_object_or_404(Cart, user=request.user)
            cart_item = get_object_or_404(CartItem, cart=cart, product__id=product_id)
            cart_item.delete()
            return Response({"message": "Item removed from cart"}, status=status.HTTP_200_OK)
        except Exception as e:
            return Response({"error": str(e)}, status=status.HTTP_400_BAD_REQUEST)







